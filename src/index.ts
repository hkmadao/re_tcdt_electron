import { app, BrowserWindow, dialog, ipcMain, IpcMainInvokeEvent, Menu, } from 'electron';
import { downloadZip, componentBatchDownloadZip, } from './components/download';
import {
  E_NodeEnv,
  fetchCodeGenerateConf, resetCodeGenerateConf, saveCodeGenerateConf,
  fetchClientConf, resetClientConf, saveClientConf,
  TClientConfig,
  TFindTableParam,
  TExecuteSqlParam,
  removeCodeGenerateConf,
} from './conf';
import { createTcdtWindow } from './windows';
import { openDialog } from './components/path-select';
import { excuteDdlSql, findTableInfos } from './components/db';
import { defalutMenu } from './menu';
import log from 'electron-log/main';

// Optional, initialize the logger for any renderer process
log.initialize();
log.info('Log from the main process');

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
//根据forge.config.js配置而来
declare const TCDT_WINDOW_WEBPACK_ENTRY: string;
declare const TCDT_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

const isPro = process.env.TCDT_ENV === E_NodeEnv.PROD

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

const generate = (event: IpcMainInvokeEvent, [url, generateType]) => {
  downloadZip(url, generateType);
}

const componentBatchGenerate = (event: IpcMainInvokeEvent, [params, generateType]) => {
  componentBatchDownloadZip(params, generateType);
}

const fetchConf = (event: IpcMainInvokeEvent, options: any[]) => {
  return fetchCodeGenerateConf();
}

const saveConf = (event: IpcMainInvokeEvent, [confData]: any[]) => {
  return saveCodeGenerateConf(confData);
}

const resetConf = (event: IpcMainInvokeEvent, options: any[]) => {
  return resetCodeGenerateConf();
}
const removeConf = (event: IpcMainInvokeEvent, [confData]: any[]) => {
  return removeCodeGenerateConf(confData);
}

const fetchCliConf = (event: IpcMainInvokeEvent, options: any[]) => {
  return fetchClientConf();
}

const saveCliConf = (event: IpcMainInvokeEvent, [confData]: (TClientConfig & { fgReOpen: boolean })[]) => {
  saveClientConf({ ...{ ...confData, fgReOpen: undefined }, }, confData.fgReOpen);
  if (confData.fgReOpen) {
    reOpen();
  }
}

const resetCliConf = (event: IpcMainInvokeEvent, options: any[]) => {
  return resetClientConf();
}

const showOpenDialog = (event: IpcMainInvokeEvent, [defalutPath]) => {
  return openDialog(defalutPath);
}

const findDbTables = (event: IpcMainInvokeEvent, [param]: TFindTableParam[]) => {
  return findTableInfos({
    host: param.host,
    user: param.user,
    password: param.password,
    port: param.port,
    database: param.database,
    tableSchema: param.tableSchema,
  })
}

const executeSql = (event: IpcMainInvokeEvent, [param]: TExecuteSqlParam[]) => {
  return excuteDdlSql({
    host: param.host,
    user: param.user,
    password: param.password,
    port: param.port,
    database: param.database,
    executeSql: param.executeSql,
  })
}

const reOpen = () => {
  const oldWins = BrowserWindow.getAllWindows();
  const focusWin = oldWins.find(w => {
    return w.isFocused()
  });
  dialog.showMessageBox(focusWin, {
    buttons: ['取消', '确定'],
    cancelId: 0,
    type: 'warning',
    title: '关闭提示',
    message: '将关闭其他窗口并打开主窗口，是否继续？',
  }).then(result => {
    if (result.response !== 0) {
      createTcdtWindow();
      oldWins.forEach(w => {
        w.close();
      });
    }
  }).catch(e => {
    log.info(e)
  });
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.whenReady().then(() => {
  ipcMain.handle('tcdt:generate', generate);
  ipcMain.handle('tcdt:componentBatchGenerate', componentBatchGenerate);
  ipcMain.handle('tcdt:fetchConf', fetchConf);
  ipcMain.handle('tcdt:saveConf', saveConf);
  ipcMain.handle('tcdt:resetConf', resetConf);
  ipcMain.handle('tcdt:removeConf', removeConf);
  ipcMain.handle('tcdt:fetchClientConf', fetchCliConf);
  ipcMain.handle('tcdt:saveClientConf', saveCliConf);
  ipcMain.handle('tcdt:resetClientConf', resetCliConf);
  ipcMain.handle('tcdt:selectPath', showOpenDialog);
  ipcMain.handle('tcdt:findDbTables', findDbTables);
  ipcMain.handle('tcdt:executeSql', executeSql);

  const menu = Menu.buildFromTemplate(defalutMenu);
  Menu.setApplicationMenu(menu)
  createTcdtWindow();

})

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
// app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  log.info('window-all-closed:', BrowserWindow.getAllWindows().length)
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

// app.on('activate', () => {
//   // On OS X it's common to re-create a window in the app when the
//   // dock icon is clicked and there are no other windows open.
//   if (BrowserWindow.getAllWindows().length === 0) {
//     createWindow();
//   }
// });

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
